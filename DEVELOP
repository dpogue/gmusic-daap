Developing using libdaap

How to create a daap server in 5 seconds:

import libdaap

Call libdaap.make_daap_server() with the backend as the argument (more on this
later).  This returns a server instance.

Call libdaap.runloop() with the server as the argument.

How to create a daap client in 5 seconds:

import libdaap

Call libdaap.make_daap_client().  This returns a daap client instance.
You then call connect() on the returned object to connect to a server.

Bonjour sharing:

You may also consider to use Bonjour sharing, you can turn this on and
off with libdaap.install_mdns().  This function returns a reference which 
you can destroy with libdaap.uninstall_mdns().

Call libdaap.browse_mdns() to have Bonjour notify you when new shares
are published on the network.

Advanced server options:

NOTE: If robust=True argument is set (the default) the server creation 
is "robust".  This means if if cannot find the port specified it will pick
an unused port.  For this reason, when you install mdns sharing you must
always check the port returned by the server.  You can do:

address, port = serverobj.server_address

to obtain the port from the server object.

An alternative way to run the server is to obtain the server's socket
descriptor, then you work out when the socket is readable then issue
a handle_request() method on it.

There are more arguments to these functions to change the port settings
among others, refer to the source code for help.

Notes on backend:

The backend is basically a object-based class that can get item information
from whatever backing store is used.

You must implement these functions:

get_items(): This gets a listing of the items in "native" format that
the server frontend expects.  In the case of libdaap, this is a
dictionary indexed by a numeric identifier (which must be > 0), and
tuples of daap/dmap codes and their corresponding values.  If you implement
playlist support you must also implement the playlist_id argument which only
returns items for a particular playlist.

get_playlists(): This can be stubbed out to return an empty list: [].  If
you don't then you must return the playlists in native libdaap format which
is a list of (mlit, [...]) listing of playlist items.  Refer to the libdaap
source code for the default 'Library' playlist on how to build one.  If you
implement this you must also implement the optional playlist_id argument
in get_items().

get_filepath(itemid): Get the full path to the file for the itemid.

Common errors:

Server returns a HTTP 403 - this could be several errors.

(1) You have tried to obtain an invalid item or you have issued an invalid
GET request that DAAP did not understand.  Many of the daap commands require
a session id which you obtain via the /login GET request.

(2) Your session has expired.  A session expires after inactivity (currently
1800 seconds) or alternatively, your daap control connection expires.
Typically, daap client implementations issue an initial connection to the
server (control connection) then issue a new connection when they try
to stream actual files (data connection).  In the case of pydaap, the
session expires when your control connection is closed.  For this reason,
you should keep the control connection alive even when you are streaming 
video.  Common mistakes include using HTTP/1.0 or using a HTTP programming
interface that adds the Connection: close headers to HTTP/1.1 connections.

The reason for doing so is it's much easier to work out whether a remote
host has gone.  For example, if a remote host connects, then does a media
listing then closes the connection.  Is the remote host done with the
session?  Or is the user just busy doing something else?  Destroying the
session on socket close seems to work with the major daap implementations and 
so this is exactly what the pydaap server implementation does.

Some implementation details: when you issue a /login request in the
control connection, a session id is created for you centrally, within the
HTTP server object.  This gets sent back to the client, but a reference
to this session id is kept in the connection handle.  When you stream, 
you initiate a new HTTP session ("data connection") with a session id 
provided to you previously as part of the query string of the HTTP request.  
This creates a new HTTP request handler.

When a connection is either closed normally (in finish() method) or abruptly 
terminated (as part of IOError exception handling, possibly a SIGPIPE), the 
code deletes the session based on the session id stored in the HTTP 
request handler.  As there is no reference to the id in the data connection,
it is immune to getting sessions deleted.  This means clients may close
data connections as they please (e.g. when user fast forward or skip over
media items) without adversely affecting the session.

When your control connection is terminated, the session disappears, at this
point you cannot rely on your session working, and the server has a right
to terminate your data connection abruptly.

Can't connect to any recent version iTunes.

Since iTunes version 7, there is a cryptographic authentication process which 
has not yet been broken, so it's impossible to connect.  This is the 
same across the board of all the open source clients that rely on a 
reverse-engineered daap protocol implementation.  There's currently no way
to test that this is the case other than that your connection failed, but
we may want to add support for this if there's a good way to do so that's
not too intrusive.

You can, however, use iTunes as a client and connect to a pydaap server.

No password support.  

pydaap does not yet support this.  It may be supported in a future version.

Rhythmbox (or possibly any other GStreamer-based application) cannot
stream from the reference daapd.py server.

We think it's because the reference server does not send the song duration 
data.  You'll need to implement a backend which supports this.
